<?php
namespace Epiphany\ServiceCacheBundle\Proxy;

use Epiphany\ServiceCacheBundle\Cache\ServiceCacheInterface;

abstract class ProxyManager {

    protected $serviceCache;

    public function __construct(ServiceCacheInterface $serviceCache) {

        $this->serviceCache = $serviceCache;
    }

    /**
     * Getter for serviceCache
     *
     * @return mixed
     */
    public function getServiceCache()
    {
        return $this->serviceCache;
    }
    
    /**
     * Setter for serviceCache
     *
     * @param mixed $serviceCache Value to set
     * @return self
     */
    public function setServiceCache($serviceCache)
    {
        $this->serviceCache = $serviceCache;
        return $this;
    }
    

    /**
     * 
     * Override this when the arguments supplied to a method don't provide a 
     * unique key or you'd prefer to define the format of the key
     *
     * the key is generated by simply string-casting each argument into an
     * underscore-seperated list 
     * 
     * @param  string $methodName [description]
     * @param  array $args        [description]
     * @return [type]             [description]
     */
    protected function getKeyForMethodWithArgs($methodName, array $args) {

        // key should be based on the parameters
        return implode('_', $args);
    }

    /**
     * Override this when you want to decide the collection name for a particular 
     * and possibly arguments
     * 
     * @param  [type] $methodName [description]
     * @param  array $args        [description]
     * @return [type]             [description]
     */
    protected function getCollectionForMethodName($methodName, $args = null) {

        // collection should be based on the namespace of the parent service class and the method call
        return str_replace("\\", '_', get_class($this) . '_' . $methodName); 
    }

    /**
     * [storedCall description]
     *
     * make a call to the service, pulling from the data store where possible
     * otherwise, call the appropriate method on the inheriting class to get
     * data from source
     * 
     * @param  [type] $methodName [description]
     * @param  [type] $args       [description]
     * @param  [type] $metaFields [description]
     * @return [type]             [description]
     */
    public function storedCall($methodName, array $args, array $metaFields) {

        $collection = $this->getCollectionForMethodName($methodName);
        $key        = $this->getKeyForMethodWithArgs($methodName, $args);

        // first check the store
        $data = $this->getServiceCache()->getDataForKey($collection, $key);

        // nothing available in the store - go get the data via the inheriting object's
        // method
        if(!$data) {

            $data = $this->callUserFuncArray($methodName, $args);

            // now store
            $this->getServiceCache()->setDataForKey($collection, $data, $key, $metaFields);
        }

        return $data;
    }

    public function callUserFuncArray($methodName, $args) {

        return call_user_func_array(array($this, $methodName), $args); 
    }

    /**
     * Make multiple calls to the supplied method name using the arguments supplied in the
     * calls array - use the data store where possible to retrieve the data
     * 
     * @param  string $methodName [description]
     * @param  array  $calls      [description]
     * @return array              return daa for each call
     */
    public function storedBatchCall($methodName, array $calls) {

        $collection = $this->getCollectionForMethodName($methodName);
        $keys = array();

        // first, get anything we can from the data store
        foreach ($calls as $call) {

            $keys[] = $this->getKeyForMethodWithArgs($methodName, $args);        
        }

        $batchedData = $this->getServiceCache()->getDataForKeyBatched($collection, $keys);

        $returnData = array();

        $dataToCache = array();

        foreach($calls as $callIndex => $args) {

            // init index
            $returnData[$callIndex] = null;

            $key = $this->getKeyForMethodWithArgs($methodName, $args);  

            if(isset($batchedData[$key])) { // data was stored in the data store

                $returnData[$callIndex] = $batchedData[$key];
            }
            else { // no data available - make an API call and store

                $data = $this->callUserFuncArray($methodName, $args);

                $dataToCache[$key] = $data;

            }
        }

        // if we need to store anything then do so
        if(count($dataToCache)) {

            $this->getServiceCache()->setDataForKeyBatched($collection, $dataToCache);
        }

        return $returnVals;
    }
}